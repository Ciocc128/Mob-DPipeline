# Import necessary libraries for data manipulation, signal processing, and rotations
from mobgap.data import GenericMobilisedDataset
import numpy as np
from scipy.spatial.transform import Rotation as R
from gaitmap.utils.rotations import rotate_dataset
import matplotlib.pyplot as plt
from scipy.signal import hilbert

# --- Utility Functions ---

def unit(vector):
    """
    Normalize a vector to unit length.

    Parameters:
        vector (np.ndarray): Input vector to normalize.

    Returns:
        np.ndarray: Normalized unit vector.
    """
    return vector / np.linalg.norm(vector)


def compute_envelope(signal):
    """
    Compute the envelope of a signal using the Hilbert transform.

    Parameters:
        signal (np.ndarray): The input signal (e.g., magnitude of accelerometer data).

    Returns:
        np.ndarray: The envelope of the signal.
    """
    # Calculate the analytic signal using the Hilbert transform
    analytic_signal = hilbert(signal)
    # The envelope is the magnitude of the analytic signal
    envelope = np.abs(analytic_signal)
    return envelope


def detect_stationary_period(acc_data, threshold=0.01, window_size=50):
    """
    Detect the stationary period in accelerometer data based on the signal's envelope.

    Parameters:
        acc_data (np.ndarray): An N x 3 array of accelerometer data.
        threshold (float): Threshold for the envelope to determine the stationary state.
        window_size (int): Size of the window for calculating variance in the stationary state.

    Returns:
        np.ndarray: Subset of data during the detected stationary period.
    """
    # Calculate the magnitude of the accelerometer data (sqrt(x^2 + y^2 + z^2))
    acc_magnitude = np.linalg.norm(acc_data, axis=1)

    # Compute the envelope of the magnitude signal
    envelope = compute_envelope(acc_magnitude)

    # Identify stationary regions where the envelope is below the threshold
    stationary_mask = envelope < threshold
    stationary_indices = np.where(stationary_mask)[0]

    # If no stationary region is detected, fallback to using the first part of the signal
    if len(stationary_indices) == 0:
        print("No clear stationary period detected. Defaulting to first part of the signal.")
        return acc_data[:window_size]

    # Use the first contiguous block of stationary indices
    start_idx = stationary_indices[0]
    end_idx = start_idx + window_size
    stationary_data = acc_data[start_idx:end_idx]

    return stationary_data


def calc_R(acc_data):
    """
    Calculate the rotation matrix to align the accelerometer data with the gravity vector.

    Parameters:
        acc_data (np.ndarray): An N x 3 array of accelerometer data.

    Returns:
        np.ndarray: The rotation matrix (3x3) to align the data with the gravity vector.
    """
    # Ideal gravity vector, assumed to be along the X-axis
    gravity_local_ideal = np.array([1, 0, 0])

    # Detect the stationary period and compute the real gravity vector
    stationary_data = detect_stationary_period(acc_data)
    gravity_local_real = unit(np.mean(stationary_data, axis=0))

    # Log the detected gravity vector for verification
    print(f"Real gravity vector: {gravity_local_real}")

    # Calculate the angle between the real and ideal gravity vectors
    angle = np.degrees(np.arccos(np.clip(np.dot(gravity_local_real, gravity_local_ideal), -1.0, 1.0)))

    # Calculate the rotation axis using the cross product
    rotation_axis = unit(np.cross(gravity_local_real, gravity_local_ideal))
    half_angle_rad = np.radians(angle / 2)

    # Create a quaternion from the angle and axis, and convert it to a rotation matrix
    q = np.hstack(([np.cos(half_angle_rad)], rotation_axis * np.sin(half_angle_rad)))
    rotation_matrix = R.from_quat(q).as_matrix()

    return rotation_matrix


def rotate_with_gaitmap(data, rotation_matrix):
    """
    Rotate the accelerometer and gyroscope data using a rotation matrix.

    Parameters:
        data (pd.DataFrame): DataFrame containing accelerometer and gyroscope data.
        rotation_matrix (np.ndarray): A 3x3 rotation matrix.

    Returns:
        pd.DataFrame: The rotated dataset.
    """
    rotation = R.from_matrix(rotation_matrix)  # Create a Rotation object

    # Ensure that the DataFrame has the necessary columns
    required_columns = ['acc_x', 'acc_y', 'acc_z', 'gyr_x', 'gyr_y', 'gyr_z']
    if not all(col in data.columns for col in required_columns):
        raise ValueError("DataFrame must contain 'acc_x', 'acc_y', 'acc_z', 'gyr_x', 'gyr_y', 'gyr_z' columns")

    # Rotate the accelerometer and gyroscope data
    rotated_acc = rotate_dataset(data[['acc_x', 'acc_y', 'acc_z']].values, rotation)
    rotated_gyr = rotate_dataset(data[['gyr_x', 'gyr_y', 'gyr_z']].values, rotation)

    # Update the DataFrame with the rotated data
    data[['acc_x', 'acc_y', 'acc_z']] = rotated_acc
    data[['gyr_x', 'gyr_y', 'gyr_z']] = rotated_gyr

    return data


def process_and_rotate_dataset(dataset, exercise_name):
    """
    Main function to process and rotate the dataset based on the detected stationary state and gravity alignment.

    Parameters:
        dataset (pd.DataFrame): Input dataset containing accelerometer and gyroscope data.
        exercise_name (str): Name of the exercise for logging and visualization purposes.
    """
    # Ensure the dataset has the required columns
    required_columns = ['acc_x', 'acc_y', 'acc_z', 'gyr_x', 'gyr_y', 'gyr_z']
    if not all(col in dataset.columns for col in required_columns):
        raise ValueError("DataFrame must contain 'acc_x', 'acc_y', 'acc_z', 'gyr_x', 'gyr_y', 'gyr_z' columns")

    # Extract the accelerometer data from the dataset
    acc_data = dataset[['acc_x', 'acc_y', 'acc_z']].values
    print(f"Exercise: {exercise_name} - Accelerometer data:\n", dataset[['acc_x', 'acc_y', 'acc_z']])

    # Step 1: Calculate the rotation matrix to align the data with gravity
    R_real_ideal_HD = calc_R(acc_data)

    # Step 2: Apply the rotation to align the accelerometer data with gravity
    aligned_df = rotate_with_gaitmap(dataset, R_real_ideal_HD)
    print(f"Exercise: {exercise_name} - Aligned accelerometer data:\n", aligned_df[['acc_x', 'acc_y', 'acc_z']])

    # Step 3: Apply an additional rotation to align the data with the Mobilise-D reference system
    additional_rotation_matrix = np.array([
        [1, 0, 0],    # X' = X
        [0, -1, 0],   # Y' = -Y
        [0, 0, -1]    # Z' = -Z
    ])

    # Convert the additional rotation matrix to a Rotation object
    additional_rotation = R.from_matrix(additional_rotation_matrix)

    # Apply the additional rotation
    final_rotated_df = rotate_with_gaitmap(aligned_df, additional_rotation.as_matrix())
    print(f"Exercise: {exercise_name} - Final rotated accelerometer data:\n", final_rotated_df[['acc_x', 'acc_y', 'acc_z']])

    # Optional: Plot the aligned data
    plot_data(dataset[['acc_x', 'acc_y', 'acc_z']], aligned_df[['acc_x', 'acc_y', 'acc_z']], f"(Exercise: {exercise_name})")

    # If you want to visualize the gyroscope data, you can add separate plots for it.
    # plot_data(dataset[['gyr_x', 'gyr_y', 'gyr_z']], final_rotated_df[['gyr_x', 'gyr_y', 'gyr_z']], f"(Gyroscope - {exercise_name})")



# %%
